classdef posstab
    %POSSTAB Data-driven stabilization of a discrete-time linear positive 
    %system using full-state-feedback and a common linear copositive 
    %control lyapunov function
    
    properties
        %start traj with only one trajectory, then expand to multiple
        traj; %trajectory trace
        
        delta = 1e-4; %tolerance for a strict inequality to be positive       
        
        opts = sdpsettings('solver', 'mosek','robust.lplp', 'duality');

        poly;

    end
    
    methods
        function obj = posstab(traj)
            %POSSTAB Construct an instance of this class
            %   Detailed explanation goes here
            obj.traj = traj;
            
            [C, d] = obj.data_cons(traj);
            obj.poly = struct('C', C, 'd', d);
        end
        
        function [out] = solve_program(obj, cons, objective, vars)
            %run the program
            sol = optimize(cons, objective, obj.opts);
            out.sol = sol;
            
            if sol.problem==0
                %successful trajectory execution
                out = obj.recover(vars, sol);
            end
        end   
        
        function [out] = stab(obj)
            %STAB: main stabilization routine and execution
            [cons, vars] = obj.make_program();
            out = obj.solve_program(cons, 0, vars);
        end
        
        %% helper programs
        
        function [cons, vars] = make_program(obj)
           %MAKE_PROGRAM form the LMI program in YALMIP
            vars =  obj.make_vars();
            
            cons_vars = [y >= obj.delta; sum(y)==1];
            
            pall = reshape([vars.A, vars.B], [], 1);
            cons_data = obj.poly.d - obj.poly.C*pall;
            
            cons_stab = obj.cons_stab(vars);
            
            cons = [uncertain(pall); cons_vars; cons_data; cons_stab];
        end       
        
        function cons = cons_stab(obj, vars)
            %constraint to enforce stability
            n = size(vars.A, 1);
            stab = y' - ones(1, n)*(vars.A*diag(y) + vars.B*S);
            
            cons = (stab >= obj.delta);
        end
        
        function [vars] = make_vars(obj)
            %generate uncertain and decision variables
           n = size(obj.traj.Xdelta, 1);
           m = size(obj.traj.U, 1);
           
           %uncertain variables
           A = sdpvar(n, n);
           B = sdpvar(n, m);
           
           %decision variables
           y = sdpvar(n, 1);
           S = sdpvar(m, n);
           
           vars = struct('A', A, 'B', B, 'y', y, 'S', S);                      
        end
        
    
        
        function [C, d] = data_cons(obj, traj)
            %DATA_CONS generate the polytope constraint associated with the
            %given trajectory/data
            %Inputs:
            %   traj:   trajectory
            %
            %Outputs:
            %   [C, d]: Polytope C x <= d for parameters x 
            %           (vectorized [A;B])
            
            [Cdata, ddata] = data_cons(traj, 0); %data constraints from trajectory
            [Cpos, dpos] = obj.pos_cons(traj);   %must have been generated by a positive system
            
            [C, d] = nontrivial_constraints([Cdata; Cpos], [ddata; dpos]);
            
        end
        
        function [Cpos, dpos] = pos_cons(obj, traj)
            %POS_CONS generate linear constraints such that the
            %ground-truth system is positive
            %
            %for discrete-time, all elements of A must be nonnegative
            %Inputs:
            %   traj:   trajectory
            %
            %Outputs:
            %   [Cpos, dpos]: Polytope Cpos x <= dpos for parameters x 
            %           (vectorized [A;B])     
            
            
            n = size(traj.Xdelta, 1);
            m = size(traj.U, 1);
            
            ipos = (1:n^2);
            jpos = (1:n^2);
            vpos = -ones(1, n^2);
            
            Cpos = sparse(ipos, jpos, vpos, n^2, n*(n+m));
            dpos = sparse([], [], [], n^2, 1);                        
        end
        
        %% recovery
        function out = recover(obj, vars, sol)
            %RECOVER get the controllers and parameters
            out = struct;
            %variables
            out.sol = sol;
            out.y = value(vars.y);
            out.v = 1);
            
            %parameter-independent quadratic lyapunov function
            out.Y = value(vars.Y);
            
            Nv = length(vars.M);
            %controllers and qmi
            out.K = cell(Nv, 1);
            out.M = cell(Nv, 1);
            out.Cv = cell(Nv, 1);
            
            
            out.eig_Y = eig(out.Y);
            sv = size(vars.Cv{1}, 1);
            out.eig_Cv = zeros(sv, Nv);
            for v = 1:Nv
                out.M{v} = value(vars.M{v});
                out.K{v} = (out.Y \ out.M{v}')';
                out.Cv{v} = value(vars.Cv{v});                
                out.eig_Cv(:, v) =eig(out.Cv{v});
            end
        end
    end
end


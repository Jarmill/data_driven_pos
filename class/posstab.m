classdef posstab
    %POSSTAB Data-driven stabilization of a discrete-time linear positive 
    %system using full-state-feedback and a common linear copositive 
    %control lyapunov function
    
    properties
        %start traj with only one trajectory, then expand to multiple
        traj; %trajectory trace
        
        delta = 1e-4; %tolerance for a strict inequality to be positive       
        
        opts = sdpsettings('solver', 'mosek');

        poly;

    end
    
    methods
        function obj = posstab(traj)
            %POSSTAB Construct an instance of this class
            %   Detailed explanation goes here
            obj.traj = traj;
            
            [C, d] = obj.data_cons(traj);
            obj.poly = struct('C', C, 'd', d);
        end
        
        function [C, d] = data_cons(obj, traj)
            %DATA_CONS generate the polytope constraint associated with the
            %given trajectory/data
            %Inputs:
            %   traj:   trajectory
            %
            %Outputs:
            %   [C, d]: Polytope C x <= d for parameters x 
            %           (vectorized [A;B])
            
            [Cdata, ddata] = data_cons(traj, 0); %data constraints from trajectory
            [Cpos, dpos] = obj.pos_cons(traj);   %must have been generated by a positive system
            
            [C, d] = nontrivial_constraints([Cdata; Cpos], [ddata; dpos]);
            
        end
        
        function [Cpos, dpos] = pos_cons(obj, traj)
            %POS_CONS generate linear constraints such that the
            %ground-truth system is positive
            %
            %for discrete-time, all elements of A must be nonnegative
            %Inputs:
            %   traj:   trajectory
            %
            %Outputs:
            %   [Cpos, dpos]: Polytope Cpos x <= dpos for parameters x 
            %           (vectorized [A;B])     
            
            
            n = size(traj.Xdelta, 1);
            m = size(traj.U, 1);
            
            ipos = (1:n^2);
            jpos = (1:n^2);
            vpos = -ones(1, n^2);
            
            Cpos = sparse(ipos, jpos, vpos, n^2, n*(n+m));
            dpos = sparse([], [], [], n^2, 1);
            
            
        end
    end
end


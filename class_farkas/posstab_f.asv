classdef posstab_f
    %POSSTAB_F Data-driven stabilization of a discrete-time linear positive 
    %system using full-state-feedback and a common linear copositive 
    %control lyapunov function
    %
    %Utilizes the Extended Farkas Lemma, does not require the Yalmip robust
    %optimization toolbox anymore
    
    properties
        %start traj with only one trajectory, then expand to multiple
        traj; %trajectory trace
        
        delta = 1e-3; %tolerance for a strict inequality to be positive       
        
        opts = sdpsettings('solver', 'mosek','robust.lplp', 'duality');

        poly;

        nontrivial = 1; %eliminate trivial constraints from the polytope
        
    end
    
    methods
        function obj = posstab_f(traj)
            %POSSTAB Construct an instance of this class
            %   Detailed explanation goes here
            obj.traj = traj;
            
            [C, d] = obj.data_cons(traj);
            obj.poly = struct('C', C, 'd', d);
        end
        
        function [out] = solve_program(obj, cons, objective, vars)
            %run the program
            sol = optimize(cons, objective, obj.opts);
            out.sol = sol;
            
            if sol.problem==0
                %successful trajectory execution
                out = obj.recover(vars, sol);
            end
        end   
        
        function [out] = run(obj)
            %STAB: main stabilization routine and execution
            [cons, vars] = obj.make_program();
            objective = obj.make_objective(vars);
            out = obj.solve_program(cons, objective, vars);
        end
        
        %% helper programs
        
        function [cons, vars] = make_program(obj)
           %MAKE_PROGRAM form the LMI program in YALMIP
            vars =  obj.make_vars();
            
            %valid and normalized (inverse) lyapunov weights
            cons_vars = [vars.y >= obj.delta; sum(vars.y)==1];
            
            pall = reshape([vars.A, vars.B], [], 1);
            cons_data = (obj.poly.d - obj.poly.C*pall) >= 0;
            
            [cons_stab, stab_label]= obj.cons_stab(vars);
            
            cons_pos_closed = obj.pos_cons_closed(vars);
            
            cons = [uncertain(pall):'Plant (A, B)'; cons_vars:'Lyap Nonneg';...
                cons_data:'Data Consistency'; cons_stab:stab_label; ...
                cons_pos_closed:'Closed-loop positive'];
        end       
        
        function objective = make_objective(obj, vars)
            objective = 0;
        end
        
        function [cons, stab_label]= cons_stab(obj, vars)
            %constraint to enforce stability
            n = size(vars.A, 1);
%             stab = vars.y' - ones(1, n)*(vars.A*diag(vars.y) + vars.B*vars.S);
            stab = vars.y - (vars.A*diag(vars.y) + vars.B*vars.S)*ones(n, 1);
            cons = (stab >= obj.delta);
            stab_label = 'Stability';
        end
        
        function poly = poly_stab(obj, vars)
            %POLY_STAB generate the polytope of positive-stabilizable 
            %systems given the values in vars
            
            n = length(vars.y);
            Gc_stab = [kron(-vars.y', eye(n)), kron(-sum(vars.Y, 2)', eye(n))];
            
            M = metzler_indexer(n);
            Gc_pos_all = [kron(diag(vars.y), kron(eye(n))
            
        end
        
        function [vars] = make_vars(obj)
            %generate uncertain and decision variables
           n = size(obj.traj.Xdelta, 1);
           m = size(obj.traj.U, 1);
           
%            %uncertain variables
%            A = sdpvar(n, n, 'full');
%            B = sdpvar(n, m, 'full');
           
           %decision variables
           y = sdpvar(n, 1);
           S = sdpvar(m, n, 'full');
           
           vars = struct('y', y, 'S', S);                   
        end
        
    
        
        function [C, d, F_old] = data_cons(obj, traj)
            %DATA_CONS generate the polytope constraint associated with the
            %given trajectory/data
            %Inputs:
            %   traj:   trajectory
            %
            %Outputs:
            %   [C, d]: Polytope C x <= d for parameters x 
            %           (vectorized [A;B])
            %   F_old:  Prior number of faces
            
            [Cdata, ddata] = data_cons(traj, 0); %data constraints from trajectory
            [Cpos, dpos] = obj.pos_cons(traj);   %must have been generated by a positive system
            
            F_old = length(ddata) + length(dpos);
            
            if obj.nontrivial            
                [C, d] = nontrivial_constraints([Cdata; Cpos], [ddata; dpos]);
            else
                C = [Cdata; Cpos];
                d = [ddata; dpos];
            end
            
        end
        
        function [Cpos, dpos] = pos_cons(obj, traj)
            %POS_CONS generate linear constraints such that the
            %ground-truth system is positive
            %
            %for discrete-time, all elements of A must be nonnegative
            %also, all elements of B must be nonnegative
            %Inputs:
            %   traj:   trajectory
            %
            %Outputs:
            %   [Cpos, dpos]: Polytope Cpos x <= dpos for parameters x 
            %           (vectorized [A;B])     
            n = size(traj.Xdelta, 1);
            m = size(traj.U, 1);
            
%             ipos = (1:n^2);
%             jpos = (1:n^2);
%             vpos = -ones(1, n^2);
            
            Cpos = -speye(n*(n+m));
            dpos = sparse([], [], [], n*(n+m), 1);

%             Cpos = sparse(ipos, jpos, vpos, n^2, n*(n+m));
%             dpos = sparse([], [], [], n^2, 1);                        
        end
        
        function cons = pos_cons_closed(obj, vars)
            %the closed-loop system should also be positive (nonnegative)
            pall = reshape(vars.A* diag(vars.y) + vars.B*vars.S, [], 1);
            cons = (pall >= 0);
        end
        
        %% recovery
        function out = recover(obj, vars, sol)
            %RECOVER get the controllers and parameters
            out = struct;
            %variables
            out.sol = sol;
            
            %copositive linear control lyapunov function
            out.y = value(vars.y);
            out.v = 1./out.y;
            
            %control action
            out.S = value(vars.S);
            out.K = out.S*diag(out.v);
            
        end
    end
end


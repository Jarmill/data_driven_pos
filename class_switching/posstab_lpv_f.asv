classdef posstab_lpv_f < posstab_f
    %POSSTAB_LPV_F Data-driven stabilization of a switched discrete-time 
    % linear parameter-varying positive system using full-state-feedback 
    % (gain) and a common dual-linear copositive control lyapunov function
    %
    %Utilizes the Extended Farkas Lemma, does not require the Yalmip robust
    %optimization toolbox anymore
    
    properties        
        Th_vert; 
        L;
    end

    methods
        function obj = posstab_lpv_f(traj, Th_vert, dopts)
            %POSSTAB_CONT Construct an instance of this class
            %   Detailed explanation goes here
            if nargin < 3
                dopts = data_opts;
            end

            
            

            obj@posstab_f(traj, dopts);
			
			%load in the parameter data
			obj.Th_vert  = Th_vert;
            obj.L = length(traj.L);

            %report data-consistency polytope information
            %sys_cons:  number of linear constraints describing each
            %           subsystem
            %F_old:     number of linear constraints that were present
            %           before eliminating trivial faces

            obj.poly.sys_cons = obj.poly.F_old.sys_cons;
            obj.poly.F_old = obj.poly.F_old.F_old;

        end
		
        function [vars] = make_vars(obj)
            %generate uncertain and decision variables
           n = size(obj.traj.Xdelta, 1);
           m = size(obj.traj.U, 1);
           %decision variables
           y = sdpvar(n, 1);
           S = sdpvar(m, n,,obj.L, 'full');
           
           vars = struct('y', y, 'S', S);                   
        end
        		

        function [Cpos, dpos] = pos_cons(obj, traj, data_options)
%POS_CONS generate linear constraints such that the
            %ground-truth system is positive
            %
            %for discrete-time, all elements of A must be nonnegative
            %also, all elements of B must be nonnegative
            %Inputs:
            %   traj:   trajectory
            %
            %Outputs:
            %   [Cpos, dpos]: Polytope Cpos x <= dpos for parameters x 
            %           (vectorized [A;B])     
            n = size(traj.Xdelta, 1);
            L = traj.L;
            m = size(traj.U, 1);
            Ncon = 0;            
            if data_options.pos_A
                ipos = (1:(L*n^2));
                jpos = (1:(L*n^2));
                vpos = -ones(1, (L*n^2));
                
                dpos = sparse([], [], [], n^2, 1);
                Ncon = Ncon + (L*n^2);
                
                if data_options.pos_B
                    ipos = [ipos, n^2 + (1:(n*m))];
                    jpos = [jpos, n^2 + (1:(n*m))];
                    vpos = [vpos, -ones(1, n*m)];

                    dpos = [dpos; sparse([], [], [], n*m, 1)];
                    Ncon = Ncon + n*m;
                end
            else
                ipos = [];
                jpos = [];
                vpos = [];
                dpos = [];
            end
            
        end

        %possibly implement per-subsystem sign constraints later.
        %right now, the sign constraints are common among all subsystems
%        function cons_K = controller_cons(obj, vars, dopts)

		
        
        function poly_out = poly_stab(obj, vars)
            %POLY_STAB generate the polytope of positive-stabilizable 
            %subsystems given the values in vars
			%with a common Lyapunov function and controller K (switching-independent)
			
			poly_out_sys = poly_stab@posstab_f(obj, vars);
			
			poly_out = struct('C', kron(eye(obj.L), poly_out_sys.C), 'd', kron(ones(obj.L, 1), poly_out_sys.d));
			                 
        end

    end
end


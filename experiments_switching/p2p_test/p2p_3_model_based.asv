%discrete-time p2p



A0 = [-0.2, 0.2, 0.2; 0.4, -0.7, 0.2; 0, 0.8, -3];
B0 = [-0.4, 0.5; 0.2, -0.8; -1, 2];

A1 = [-1, 2, 0; 2, -3, 1; 1, 1, 3];
B1 = [1 0; -2 0; -1 -1];

A2 = diag([0.8; -0.7; 1.2]) + 0.1*ones(3, 3);
B2 = [0 1; 1 1; 1 0];
% B2 = [0 1; 0 -1; 3 -2];

A = {A0, A1, A2};
B = {B0, B1, B2};

n = 3;
C = eye()

SCENARIO = 2;
%0: same controller on all modes
%1: different controller on all modes
%2: periodic switching A0 -> A1 -> A2

n = size(A1, 1);
m = size(B1, 2);
N = length(A);

% lam = [-10, 10; 10, -10];

v = sdpvar(n, N, 'full');
S = sdpvar(m, n, N);
% Lam = ones(n, N)*50; %a nonnegative matrix satisfying Lam*1 = 1 (markov)
Lam = zeros(n, N);
lm_expr = zeros(n, N, 'like', sdpvar);
for i = 1:N
    for j = 1:N
        if j ~= i
            lm_expr(:, i) = lm_expr(:, i) + Lam(i, j)*(v(:, j)- v(:, i));
        end
    end
end

n = length(A1);
z1 = sdpvar(n, 1);
z2 = sdpvar(n, 1);

% z1 = [0.4483; 0.5001];
% z2 = [0.447; 0.5493];

delta = 1e-3;
stab_con = [];
pos_con = [];
% M = metzler_indexer(n);
for i = 1:N
    if SCENARIO == 2
        vnext = v(:, mod(i, N)+1);
    else
        vnext = v(:, i);
    end

    stab_con_curr = -vnext+ A{i}*v(:, i) + B{i}*squeeze(S(:, :, i))*ones(n, 1)+ lm_expr(:, i);
    stab_con = [stab_con; stab_con_curr];
end

for i = 1:N
    pos_con_curr = reshape(A{i}*diag(v(:, i)) + B{i}*squeeze(S(:, :, i)), [], 1);

    pos_con = [pos_con; pos_con_curr];
end

K_con = [];
if SCENARIO == 0
    for i = 1:N-1
        K_con = [K_con; S(:, :, i) == S(:, :, i+1)];
    end
end

cons = [stab_con <= (-delta); reshape(v, [], 1) >= delta; pos_con>=0; K_con];

sol = optimize(cons, []);

% z = {value(z1), value(z2)};
v_rec = value(v);
S_rec = value(S);
K_rec = cell(N, 1);
Acl_rec = cell(N, 1);

for i = 1:N
    Xi_rec = diag(1./v_rec(:, i));
    K_rec{i} = S_rec(:, :, i)*Xi_rec;
    Acl_rec{i} = A{i}+B{i}*K_rec{i};
end


if sol.problem==0
    abs(eig(Acl_rec{1}))'
else
    disp('infeasible')
end
